package com.felixzh;

public class readme {
    /**
     *
     * 当前, 可以实现等待通知机制的api有两组, 一组以 synchronized/wait/notify 为代表, 另一组则以 Lock/Condition 为代表.
     * 其中 synchronized 和 Lock 属于基础的锁功能, 此处不再额外介绍. 各组其余的api的功能简述如下.
     *
     * wait等api由object类提供, 也就是说, 任何可以作为锁用于synchronized的Object子类实例都可以提供这几个方法.
     * wait(): 让当前线程进入等待状态, 并释放当前对象的锁. 线程在调用 wait() 方法后, 进入"等待"状态, 直到其他线程调用同一对象上的 notify() 或 notifyAll() 方法来唤醒它.
     * notify(): 唤醒在当前对象上等待的一个线程. 这个线程将会重新竞争锁, 等待重新获得锁之后才能继续执行.
     * notifyAll(): 唤醒在当前对象上等待的所有线程. 所有等待的线程都会重新竞争锁, 并继续执行.
     *
     * 而condition提供的则是与wait/notify相对应的await()和signal(), 这几个方法都由Condition实例提供.
     * await(): 使当前线程等待, 并释放锁, 直到其他线程调用相同条件上的 signal() 或 signalAll() 方法来唤醒它.
     * awaitUninterruptibly(): 与 await() 类似, 但不响应中断.
     * signal(): 唤醒一个在该条件上等待的线程. 如果有多个线程在等待, 只会唤醒其中一个, 具体唤醒哪个线程不确定.
     * signalAll(): 唤醒所有在该条件上等待的线程.
     * */

    /**
     *
     * 设想一个单人经营的咖啡店中, 一个顾客过来购买咖啡的场景. 这里老板和顾客分别相当于线程A和线程B, 那么顾客从下单到买到咖啡总计有以下几个步骤.
     *
     * 顾客(线程B)进到咖啡店里, 扫描二维码获取咖啡菜单. 这一步等同于线程B获取锁开始执行某些操作.
     * 顾客(线程B)选择自己想要的咖啡, 下单并付款, 然后找了个小桌子坐下开始玩手机. 这一步相当于线程B执行完前置操作, 调用wait/await, 进入等待状态.
     * 老板(线程A)从后台接到新的已经付款的订单, 开始制备咖啡, 比如研磨, 加冰, 加牛奶等. 这一步相当于线程A获取到锁, 并在持有锁的期间执行A应该做的任务.
     * 老板(线程A)准备好咖啡并放在服务台上, 通知客户可以来取咖啡了. 然后发现后台没有新订单, 转身去玩手机了. 这一步相当于线程A执行完毕, 调用 notify/signal 唤醒线程B, 完成这一步后释放锁.
     * 顾客(线程B)收到提醒, 去服务台取走咖啡, 然后带着咖啡离开小店. 这一步相当于线程B被唤醒后, 尝试重新获取锁, 成功后执行后续的操作并最终释放锁.
     * */
}
